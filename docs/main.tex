
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% LaTeX Template: Project Titlepage Modified (v 0.1) by rcx
%
% Original Source: http://www.howtotex.com
% Date: February 2014
% 
% This is a title page template which be used for articles & reports.
% 
% This is the modified version of the original Latex template from
% aforementioned website.
% 
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\documentclass[12pt]{article}
\usepackage[utf8]{inputenc}
\usepackage[a4paper]{geometry}
\usepackage[myheadings]{fullpage}
\usepackage{enumitem}
\usepackage{fancyhdr}
\usepackage{lastpage}
\usepackage{graphicx, wrapfig, subcaption, setspace, booktabs}
\usepackage[T1]{fontenc}
\usepackage[font=small, labelfont=bf]{caption}
\usepackage{fourier}
\usepackage{amsmath}
\usepackage[protrusion=true, expansion=true]{microtype}
\usepackage[english]{babel}
\usepackage{sectsty}
\usepackage{url, lipsum}
\usepackage{titlesec}
\usepackage{diagbox}
\usepackage{pdfpages}

\usepackage{listings}
\usepackage{color}

\definecolor{dkgreen}{rgb}{0,0.6,0}
\definecolor{gray}{rgb}{0.5,0.5,0.5}
\definecolor{mauve}{rgb}{0.58,0,0.82}

\lstset{
  language=C++,
  aboveskip=3mm,
  belowskip=3mm,
  showstringspaces=false,
  columns=flexible,
  basicstyle={\small\ttfamily},
  numbers=none,
  numberstyle=\tiny\color{gray},
  keywordstyle=\color{blue},
  commentstyle=\color{dkgreen},
  stringstyle=\color{mauve},
  breakatwhitespace=true,
  breaklines=true,
  tabsize=2,
  xleftmargin=.2\textwidth, xrightmargin=.2\textwidth,
  otherkeywords={1, 2, 3, 4, 5, 6, 7, 8, 9, 0},
  morekeywords=[2]{1, 2, 3, 4, 5, 6, 7, 8, 9, 0},
  keywordstyle=[2]{\color{purple}}
}

\lstdefinestyle{banner}{
  xleftmargin=.2cm, xrightmargin=.2cm,
  otherkeywords={1, 2, 3, 4, 5, 6, 7, 8, 9, 0},
  morekeywords=[2]{1, 2, 3, 4, 5, 6, 7, 8, 9, 0},
  keywordstyle=[2]{\color{dkgreen}}
}

\newcommand{\HRule}[1]{\rule{\linewidth}{#1}}
\onehalfspacing
\setcounter{tocdepth}{5}
\setcounter{secnumdepth}{5}
\setcounter{MaxMatrixCols}{20}
\inputencoding{utf8}

\titleformat{\paragraph}
{\normalfont\normalsize\bfseries}{\theparagraph}{1em}{}
\titlespacing*{\paragraph}
{0pt}{3.25ex plus 1ex minus .2ex}{1.5ex plus .2ex}

%-------------------------------------------------------------------------------
% HEADER & FOOTER
%-------------------------------------------------------------------------------
\pagestyle{fancy}
\fancyhf{}
\setlength\headheight{15pt}
\fancyhead[L]{António Pedro Araújo Fraga}
\fancyhead[R]{Cranfield University}
\fancyfoot[R]{Page \thepage\ of \pageref{LastPage}}
%-------------------------------------------------------------------------------
% TITLE PAGE
%-------------------------------------------------------------------------------

\begin{document}

\title{ \fontsize{40}{90} \textsc{Small Scale for Parallel Programming}
		\\ [2.0cm]
		\HRule{0.5pt} \\
		\LARGE \textbf{Sparse Matrix-Vector Product Kernel}
		\HRule{2pt} \\ [0.5cm]
		\normalsize \today \vspace*{5\baselineskip}}

\date{}

\author{
		\textbf{António Pedro Araújo Fraga} \\
		\textbf{Student ID: 279654} \\ 
		\textbf{Cranfield University} \\
		\textbf{M.Sc. in Software Engineering for Technical Computing
		} }

\maketitle
\thispagestyle{empty}
\newpage
\tableofcontents
\thispagestyle{empty}
\newpage
\null\vspace{\fill}
\begin{abstract}
\normalsize
The product of a sparse matrix and a vector was calculated both in parallel and sequentially. The parallel procedure was executed with two different technologies, Open Multi-Processing and Compute Unified Device Architecture. Sparse matrices were stored in two different formats, Compressed Sparse Row and Ellpack. It was seen that the two formats were adequate for different types of matrices. Different procedures produced different effects, those effects were discussed and studied.
\end{abstract}
\vspace{\fill}
\thispagestyle{empty}
\newpage

%-------------------------------------------------------------------------------
% Section title formatting
\sectionfont{\scshape}
\titleformat{\section}
{\normalfont\huge\bfseries}{\thesection}{1em}{}
\titleformat{\subsection}
{\normalfont\large\bfseries}{\thesubsection}{1em}{}
\titlespacing*{\section}
{0pt}{5.5ex plus 1ex minus .2ex}{4.3ex plus .2ex}
\titlespacing*{\subsection}
{0pt}{5.5ex plus 1ex minus .2ex}{4.3ex plus .2ex}
%-------------------------------------------------------------------------------

%-------------------------------------------------------------------------------
% BODY
%-------------------------------------------------------------------------------

%-------------------------------------------------------------------------------
% Nomenclature
%-------------------------------------------------------------------------------
\begin{table}[tb]
\caption{Nomenclature}
\label{tab:notation}
\centering
\def\arraystretch{1.5}
\begin{tabular}{ll}
Matrix number of rows & $m$\\
Matrix number of columns & $n$\\
Sparse matrix & $A$\\
Vector to be multiplied & $x$\\
Resulting vector & $b$\\
Floating point operations per second & \textit{FLOPS} \\
Number of non-zero values & \textit{nz} \\
Maximum number of non-zero values per row & \textit{maxnz} \\
Average computation time of a given kernel & \textit{T} \\
\end{tabular}
\end{table}

%-------------------------------------------------------------------------------
% Introduction
%-------------------------------------------------------------------------------

\section*{Introduction}
\addcontentsline{toc}{section}{Introduction}

\par Bidimensional matrices are often represented in a bidimensional array of values of $m \times n$ elements. When matrices with this representation are multiplied by a vector, one has to iterate through every element of a matrix. This approach can be rather time expensive when dealing with large matrices.
\par Sparse Matrices have a particular characteristic. They are formed by a larger number of \textbf{zero} values, compared to the amount of \textbf{non-zero} elements. Therefore, these matrices can be represented in different formats in order to avoid multiplications by zero.\cite{sparse-gpu} The distribution of \textbf{non-zero} values within these matrices is unpredictable. Hence, one has to come up with workable formats, allowing to have knowledge of a particular row, column and value.

\subsection*{Sparse Matrices Formats}
\addcontentsline{toc}{subsection}{Sparse Matrices Formats}

\par Sparse Matrices can be stored in several formats like \textbf{DIA} (diagonal), more adequate for matrices which elements are spread across the diagonal,  and \textbf{COO} (Coordinate Format).\cite{sparse-gpu} In this project, the \textbf{CSR} (Compressed Sparse Row) and \textbf{Ellpack} formats were the only ones to be compared. Using \textbf{0-based indexing}, and having a matrix defined by,

\begin{center}
\centering
\begin{minipage}{.4\textwidth}
  \flushright
  A  =   
	$
	\begin{pmatrix}
    & \textbf{3} & \textbf{4} & 0 & 0 & 0 & \\
    & 0 & \textbf{5} & \textbf{1} & 0 & 0 & \\
    & 0 & \textbf{11} & \textbf{12} & 0 & 0 & \\
    & 0 & 0 & \textbf{2} & \textbf{13} & 0 & \\
    & 0 & 0 & 0 & \textbf{1} & \textbf{-1} & \\
	\end{pmatrix}
	$
\end{minipage}%
\begin{minipage}{.4\textwidth}
 \center
  \textit{m} = $5$
  \linebreak
  \textit{n} = $5$
\end{minipage}
\linebreak
\end{center}

\par the CSR format can be represented by declaring the number of \textit{non-zero} values, \textit{nz}. An array of values, \textit{as}, of length \textbf{\textit{nz}}. One array of pointers, \textit{irp}, indicating which value in the previous array belongs to the next row. And finally, an array of columns of length \textbf{\textit{nz}}, \textit{ja}, indicating the column index of each value. Therefore, for the given matrix, one can write the described arrays and value as,

\begin{center}
\textit{nz}  =  10 
\linebreak
\linebreak
\textit{irp}  =   
$
\begin{pmatrix}
    & 0 & 2 & 4 & 6 & 8 & \\
\end{pmatrix}
$
\linebreak
\linebreak
\textit{as}  =   
$
\begin{pmatrix}
    & 3 & 4 & 5 & 1 & 11 & 12 & 2 & 13 & 1 & -1 & \\
\end{pmatrix}
$
\linebreak
\linebreak
\textit{ja}  =   
$
\begin{pmatrix}
    & 0 & 1 & 1 & 2 & 1 & 2 & 2 & 3 & 3 & 4 & \\
\end{pmatrix}
$
\linebreak
\end{center}

\par Following a C-like syntax, the $A . x = b$ equation, with \textit{A} following the previously described format, can be solved by,

\begin{lstlisting}
for (int i = 0; i < m; ++i) {
		double temp = 0.0;
		for (int j = irp[i]; j < irp[i + 1]; ++j) {
				temp += as[j] * x[ja[j]];
		}
		y[i] = temp;
}
\end{lstlisting}

\par One can represent a matrix in the \textbf{Ellpack} format by defining two \textbf{bidimensional} arrays and one value. Declaring \textit{maxnz} as the maximum number of non-zero values in a given row, one can declare two arrays of \textit{m} rows by \textit{maxnz} elements. Similarly to the CSR format, the first array, \textit{ja}, contains the column index of each value per row. The second array, \textit{as}, contains the given values per row,

\begin{center}
\textit{maxnz}  =  2 
\linebreak
\linebreak

\begin{minipage}{.4\textwidth}
  \center
  \textit{as}  =   
$
\begin{pmatrix}
    & 3 & 4 & \\
    & 5 & 1 & \\
    & 11 & 12 & \\
    & 2 & 13 & \\
    & 1 & -1 & \\
\end{pmatrix}
$
\end{minipage}%
\begin{minipage}{.4\textwidth}
 \center
  \textit{ja}  =   
$
\begin{pmatrix}
    & 0 & 1 & \\
    & 1 & 2 & \\
    & 1 & 2 & \\
    & 2 & 3 & \\
    & 3 & 4 & \\
\end{pmatrix}
$
\end{minipage}
\linebreak
\end{center}

\par Following a C-like syntax, the $A . x = b$ equation, with \textit{A} following the previously described format, can be solved by,


\begin{lstlisting}
for (int i = 0; i < m; ++i) {
		double temp = 0.0;
		for (int j = 0; j < maxnz; ++j) {
				temp += as[i][j] * x[ja[i][j]];
		}
		y[i] = temp;
}	
\end{lstlisting}

 
\subsection*{Problem definition}
\addcontentsline{toc}{subsection}{Problem definition}

\par The problem consisted in analysing the performance produced by a developed kernel. This kernel was able to solve a \textbf{Sparse Matrix-Vector Multiplication}, $A.x = b$. Besides of being able to solve the previous equation, the code should be able to do it in parallel, using \textbf{OpenMP} (Open Multi-Processing) and \textbf{CUDA} (Compute Unified Device Architecture).
\par A set of matrices obtained from the University of Florida Sparse Matrix Collection\cite{sparse-matrices}, should be used to conduct the performance analysis. The files which contained the matrices were represented in the \textbf{Matrix Market} format, and they were read with software based on an existent reader. \cite{matrix-reader} 

\subsection*{Performance analysis}
\addcontentsline{toc}{subsection}{Performance analysis}

\par The performance of a given method could be measured in \textit{FLOPS}, the number of floating point operations per second. For each method, it was possible to calculate this value by the following formula,

\begin{center}
\large
\textit{FLOPS} = 
\huge
$
\frac{2 \times nz}{T}
$
\end{center}

\par In order to calculate the resulting vector in the $A.x = b$ equation, one has to execute \textbf{two} floating point operations per \textit{non-zero} value. Thus, the \textbf{numerator} expression of the previous division is obtained. The \textbf{denominator} is defined by the time, in seconds, to solve the equation. 

\subsection*{CPU vs GPU}
\addcontentsline{toc}{subsection}{CPU vs GPU}
OpenMP, is a technology that makes use of threads running in \textbf{C}entral \textbf{P}rocessing \textbf{U}nits. These processors, are often few compared to the number of cores present in a \textbf{G}raphics \textbf{P}rocessing \textbf{U}nits device, and the level of parallelism found in these devices is comparatively low to the level of parallelism found on GPUs. One can expect to find hundreds of cores working in parallel in a GPU. 
\par On other hand, the CUDA technology, developed by NVIDIA, offers a coding interface with a C-like syntax. Not only it allows a fast shared memory between cores within a block, but the possibility of gather data from different blocks as well. These systems allow developers to build applications capable of processing larger sets of data more quickly.\cite{cpu-gpu} 


\section*{Procedures}
\addcontentsline{toc}{section}{Procedures}
\par A parsing mechanism was developed in order to convert information in the File System into the previously referred formats. The several files were in the Matrix Market format, which describes the size of the matrix, \textbf{M} rows and \textbf{N} columns, and the number of \textit{non-zero} values. 
\par Three distinct methods were developed. The first one computed the results sequentially, the second one computed the results with OpenMP, and the third used CUDA. All the three methods were capable of computing matrices in the CSR and Ellpack formats. 
\par The results were exported into \textbf{csv} files.

\subsection*{Parsing}
\addcontentsline{toc}{subsection}{Parsing}

\par Parsing was done with by using one proper library to read sparse matrices in the \textbf{MatrixMarket} format. This format contains information about the type of matrix the program is about to read. These files begin with a banner, which describes the matrix author, date of creation, id and other fields.

\begin{lstlisting}[style=banner]
%%MatrixMarket matrix coordinate real general
%-------------------------------------------------------------------------------
% UF Sparse Matrix Collection, Tim Davis
% http://www.cise.ufl.edu/research/sparse/matrices/vanHeukelum/cage4
% name: vanHeukelum/cage4
% [DNA electrophoresis, 4 monomers in polymer. A. van Heukelum, Utrecht U.]
% id: 905
% date: 2003
% author: A. van Heukelum
% ed: T. Davis
% fields: title A name id date author ed kind
% kind: directed weighted graph
%-------------------------------------------------------------------------------
\end{lstlisting}

\par The first line of the banner describes the type of the matrix being read. The first line of the body contains information about the number of rows, columns and non-zero values. 
\par Most of the matrices in the proposed set were of type \textbf{coordinate real general}. The values are identified by three elements, row, column and value,

\begin{lstlisting}[style=banner]
1 1 .75
2 1 .075027667114587
4 1 .0916389995520797
5 1 .0375138335572935
(...)
\end{lstlisting}

but the rows and columns are identified by using an \textbf{one-indexing} format. Therefore they had to be converted into the proper format in order to be used with C-like arrays. 
\par Two matrices were of type \textbf{coordinate real symmetric}, which follow the format described above, but they only contained the upper or lower triangle of a given matrix. The matrix could trivially be represented in memory by adding one extra value with \textbf{row} and \textbf{col} swapped. Notice, that this process is not needed if a value is part of the main diagonal of a matrix, since the set contained square matrices only. The \textit{non-zero} values were incremented in these type of matrices.
\par The last type of matrices is declared as \textbf{coordinate pattern general}. In this type of matrices the values were assumed to be \textbf{one}. Therefore the body contained information about the \textbf{row} and \textbf{column} of a given value only. These matrices are often used to represent graphs.

\hfill

\par The values in the MatrixMarket format were sorted by rows, followed by sorted columns. This detail creates some problems when inserting values in the \textbf{CSR} format, since it is required to represented them in order of columns as described previously. A special data structure was used to keep the values sorted by columns when representing them in memory, a \textbf{map}. This data structure is an implementation of a Red-Black tree, where is possible to know the correct order of an element in an \textbf{O(log n)} time. Notice that it is not important to keep values sorted by columns with these representations, therefore a vector of \textbf{pairs} was chosen to be the data structure in the map value. The first element of a given pair described a column, and the second element described a value. The values were then added to the correct representations.

\subsection*{Average non-zero deviation}
\addcontentsline{toc}{subsection}{Average non-zero deviation}



\subsection*{OpenMP}
\addcontentsline{toc}{subsection}{OpenMP}

\par 

 
\section*{Solution Design}
\addcontentsline{toc}{section}{Solution Design}


\section*{Results \& Discussion}
\addcontentsline{toc}{section}{Results \& Discussion}


\pagebreak
\section*{Conclusions}
\addcontentsline{toc}{section}{Conclusions}

 

%-------------------------------------------------------------------------------
% REFERENCES
%-------------------------------------------------------------------------------
\newpage
%\addcontentsline{toc}{section}{References}
\begin{thebibliography}{0}

\bibitem{sparse}
Raphael Yuster and Uri Zwick, \textit{Fast sparse matrix multiplication}, Available at: <\url{http://www.cs.tau.ac.il/~zwick/papers/sparse.pdf}> [Accessed 28 March 2017]

\bibitem{sparse-gpu}
B. Neelima1 and Prakash S. Raghavendra, April 2012,  \textit{Effective Sparse Matrix Representation for the
GPU Architectures}, Available at: <\url{https://pdfs.semanticscholar.org/2d15/dd5d0975fff797397ad31059ec097b659e00.pdf}> [Accessed 28 March 2017]

\bibitem{sparse-matrices}
University of Florida, \textit{Sparse Matrix Collection}, Available at: <\url{https://sparse.tamu.edu/}> [Accessed 28 March 2017]

\bibitem{matrix-reader}
Matrix Market, \textit{ANSI C library for Matrix Market I/O}, Available at: <\url{https://math.nist.gov/MatrixMarket/mmio-c.html}> [Accessed 28 March 2017]

\bibitem{cpu-gpu}
B. N. Manjunatha Reddy, Dr. Shanthala S., Dr. B. R. VijayaKuma, February 2017 \textit{Performance Analysis of GPU V/S CPU for Image
Processing Applications}, Available at: <\url{https://www.ijraset.com/fileserve.php?FID=6250}> [Accessed 28 March 2017]


\end{thebibliography}
\newpage

\section*{Appendices}
\addcontentsline{toc}{section}{Appendices}


\newpage

\subsection*{Source Code}
\addcontentsline{toc}{subsection}{Source Code}


\addcontentsline{toc}{subsection}{Doxygen Documentation}

\end{document}

