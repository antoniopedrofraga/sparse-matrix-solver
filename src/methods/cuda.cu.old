#include <stdio.h>
#include <iostream>

#include "../matrix/matrix.h"
#include "../matrix/csr.h"
#include "../matrix/ellpack.h"
#include "../io/iomanager.h"
#include "../utils/utils.h"

void cudaCheckError() {
	cudaError_t e = cudaGetLastError();
	if(e != cudaSuccess) {
		printf("Cuda failure %s:%d: '%s'\n", __FILE__, __LINE__, cudaGetErrorString(e));
		exit(0);
	}
}
 
__global__ void solveCSR(CSR * csr) {
	int i = threadIdx.x;
	double temp = 0.0;
	for (int j = csr->irp[i]; j < csr->irp[i + 1] - 1; ++j) {
			temp += csr->as[j] * csr->x[csr->ja[j]];
	}
	csr->y[i] = temp;
}

__global__ void solveEllpack(Ellpack * ellpack) {
	int i = threadIdx.x;
	double temp = 0.0;
	for (int j = 0; j < ellpack->maxnz; ++j) {
		temp += ellpack->as[i][j] * ellpack->x[ellpack->ja[i][j]];
	}
	ellpack->y[i] = temp;
}

void solveCuda(IOmanager * io, std::string path, CSR * &csr, Ellpack * &ellpack) {
	
	const int m = csr->getRows();
	const int csize = sizeof(CSR);
	const int esize = sizeof(Ellpack);
	
	CSR * csr_c;
	Ellpack * ellpack_c;

	cudaMalloc((void**)&csr_c, csize);
	cudaMalloc((void**)&ellpack_c, esize);
	cudaMemcpy(csr_c, csr, csize, cudaMemcpyHostToDevice); 
	cudaMemcpy(ellpack_c, ellpack, esize, cudaMemcpyHostToDevice); 
	
	for (int k = 0; k < NR_RUNS; ++k) {
		csr->trackTime();
		solveCSR<<<1, m>>>(csr_c);
		cudaDeviceSynchronize();
		cudaCheckError();
		csr->trackTime();
		
		ellpack->trackTime();
		solveEllpack<<<1, m>>>(ellpack_c);
		cudaDeviceSynchronize();
		cudaCheckError();
		ellpack->trackTime();
	}
	
	io->exportResults(CUDA, path, csr, ellpack);

	cudaMemcpy(csr, csr_c, csize, cudaMemcpyDeviceToHost); 
	cudaMemcpy(ellpack, ellpack_c, esize, cudaMemcpyDeviceToHost);

	cudaFree(csr_c);
	cudaFree(ellpack_c);
}
